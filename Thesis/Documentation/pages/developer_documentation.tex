\section{Developer documentation}
\subsection{Detailed description of the solved problems}
\par In this section I am going to present the technical background of the solved problems. I am referencing the \verb|N4567|\cite{cpp_standard} version Working Draft of the C++ standard, which contains every C++14 features and also freely available. 
\subsubsection{Inefficient String Concatenation Check}
\subsubsection{Inefficient Stream Use Check}
\subsubsection{Default Container Initialization Check}
\subsubsection{Polymorphic Shared Pointer Cehck}
\par Accoring to the C++ standard the \verb|memory| header has to contain a templated class \verb|shared_ptr| with the signature \verb|template<class T> class shared_ptr|\cite[\S20.8.2.2]{cpp_standard} \medskip
\par This class is responsible for storing a standard C++ pointer and implementing shared ownership of this raw pointer. This means that the last \verb|shared_ptr| object is responsible for the destruction of the underlying pointer. \medskip
\par The way \verb|shared_ptr| achieves the shared ownership is by a class-wide static variable (\verb|use_count()|) which is incremented in each construction and decremented in each destruction and if \verb|use_count()|  reaches zero in a destruction then the underlying pointer shall be destroyed either by default \verb|delete| keyword or by a user-supplied custom deleter. The modification of the reference count has to be an atomic process and should not be modified simultaneously\cite[\S20.8.2.2 4.]{cpp_standard}. \medskip
\par These properties could make the \verb|shared_ptr| a hidden source of performance hogs when implicit temporary object creation is involved.  Such as the case when inherit is used. \medskip
\par The standard says that a pointer to a derived class shall always be implicit convertible to a pointer to the base class\cite[\S4.10 3.]{cpp_standard}. Also in C++ objects generated  by template instantiations are not covariant, they are invariant in fact, meaning there is no implicit conversion in this example, but a compile time error:
 \begin{lstlisting}[language=c++, frame=single]
struct A {}; struct B : A {};
std::vector<B*> vec1;
std::vector<A*> vec2;
vec2 = vec1;
\end{lstlisting}
\par Yet to make \verb|shared_ptr<A>| covariant, to preserve to resemblence to a raw pointer, the standard defines constructors with signature 
\\ \verb|template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;|\\ 
\verb|template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;| \\
\cite[\S20.8.2.2.1]{cpp_standard}
 which should be eligible for overload resolution if and only  if \verb|T*| is convertible to \verb|Y*|. \medskip
 \par This entails that a \verb|shared_ptr<A>| shall be implicit convertible to \verb|shared_ptr<B>| if \verb|A| is a derived class from \verb|B| and \verb|B| is accessible and unambiguous. But this conversion is costly, because of the reference counting, which in this case decrements the reference count in \verb|shared_ptr<Derived>| and increments in \verb|shared_ptr<Base>|. This incrementing, decrementing is unnecessary and resource consuming.
\subsection{Implementations}
\subsubsection{Inefficient String Concatenation Check}
\subsubsection{Inefficient Stream Use Check}
\subsubsection{Default Container Initialization Check}
\subsubsection{Polymorphic Shared Pointer Cehck}
\subsection{Program Structure}
\par This section covers the abstract structure of the application in Clang-tidy project. The visualization is done with the Unified Modelling Language (UML for short), which is a standard way of representing different logical and physical connections in a computer software. We use UML Class diagrams to visualize the methods and fields of an object, representing also the visibility of these components from the outside of the class.  \medskip
\par In Figure:\ref{inheritence} we visualize each module's ancestor and how these modules are decoupled from each other.  
\begin{figure}[H]
 	\caption{Inheritence diagram}
 	\includegraphics[scale=1]{images/inheritence.pdf}
 	\label{inheritence}
\end{figure}
\par Every module extends from the \verb|ClangTidyCheck| class, which provides the interface of a Clang-tidy module to create the AST-matchers and also how the matched code should be handled afterwards. First step of adding a new module to Clang-tidy is to inherit from this class and implement the methods, which can be used also to send extra parameters to the checkers themselves.
\begin{figure}[H]
	\caption{UML class diagram of Inefficient Stream Use checker}
	\centering
	\includegraphics[scale=1.8]{images/InefficientStreamUse.pdf}
	\label{stream_check_class}
\end{figure}
\par In Figure:\ref{stream_check_class} you can observe one of the simplest module's UML Class diagram, which implements the methods declared by \verb|ClangTidyCheck| and also defines one static free function in the source file.
\begin{figure}[H]
	\caption{UML class diagram of Container Default Initializer check}
	\centering
	\includegraphics[scale=0.85]{images/ContainerDefaultInitializer.pdf}
	\label{container_init_class}
\end{figure}
\par Figure:\ref{container_init_class} represents the abstract structure of the Container Default Initializer check. The solved problem in this module is more complex than the rest hence the increased complexity in the abstract structure. This checker uses several helper functions, and utility classes to store all the meta information about the containers and the conversions taking place in instantiating them. 
\begin{figure}[H]
	\caption{UML class diagram of Inefficient String Concatenation check}
	\centering
	\includegraphics[scale=1.8]{images/InefficientStringConcatenation.pdf}
	\label{string_concat_check}
\end{figure}
\par The next module's architecture is fairly simple again, as seen in Figure:\ref{string_concat_check}. It consists of the basic interface of a Clang-tidy checker, but it uses a new method \verb|storeOptions| to be able to receive a passed parameter, and modify its behaviour accordingly. 
\begin{figure}[H]
	\caption{UML class diagram of Inefficient Shared Pointer check}
	\centering
	\includegraphics[scale=1.8]{images/InefficientSharedPtr.pdf}
	\label{shared_ptr_check}
\end{figure}
\par In Figure:\ref{shared_ptr_check} you can inspect the structure of the Inefficient Shared Pointer checker which declares two extra static methods for retrieving extra information about the matched nodes. 