\section{Developer documentation}
\subsection{Detailed description of the solved problems}
\par In this section I am going to present the technical background of the mentioned problems, why they are inefficient and what can we do to refactor them. I am referencing the \verb|N4567|\cite{cpp_standard} version Working Draft of the C++ standard, which contains every C++14 features and also freely available. 
\subsubsection{Inefficient String Concatenation Check}
\par As the C++ standard defines the Strings library it provides several ways of concatenating two strings together, \verb|a = a + b;|, \verb|a += b;| and \verb|a.append(b);|. \medskip
\par The first one requires two operators to be declared, the first is \verb|operator+| for \verb|basic_string| \cite[\S21.4.8.1]{cpp_standard}: 
\begin{verbatim}
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(const basic_string<charT,traits,Allocator>& lhs,
          const basic_string<charT,traits,Allocator>& rhs);
\end{verbatim}
\par And also the \verb|basic_string| constructor.
\subsubsection{Inefficient Stream Use Check}
\par This problem consists of two parts. Firstly what makes it marginally inefficient to stream characters as strings. The standard defines that the hierarchy of the classes which handle Input/Output should look like in Figure:\ref{cpp_io_hierarch}. 
\begin{figure}[H]
	\caption{C++ IO hierarchy}
	\centering
	\includegraphics[scale=0.6]{images/cpp_io_structure.pdf}
	\label{cpp_io_hierarch}
\end{figure}
\par In \verb|basic_ostream| there are several overloads of \verb|operator<<| however we are only interested in two particular overload:
\begin{itemize}
	\item \begin{verbatim}
		template<class traits>
basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&,
char);
	\end{verbatim}
	\item \begin{verbatim}
template<class traits>
basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&,
const char*);
\end{verbatim}
\end{itemize}\cite[\S27.7.3.6.4]{cpp_standard}
These overloads enable the \verb|basic_ostream| object to accept both \verb|<< "A"| and \verb|<< 'A'| structures. \medskip
\par These two overloads both achieve the same goal, however performance-wise they are not the same, since \verb|"A"| structure will be represented by \verb|const char[2]|\footnote{strings are closed by null bytes in C++ so it would look like 'A'\textbackslash 0} in the code while \verb|'A'| will be only a single instance \verb|char|. And since arrays can be implicitly converted to pointers\cite[\S4.2]{cpp_standard} the former version will call the overload with \verb|const char*| in its signature.
\par The only problem with \verb|const char*| is that the length of the string is not known, so it must be processed until the tailing null-byte is found. On the contrary when using \verb|char| the length is known, so no extra computation is required. However since modern CPUs are quite fast this extra computational complexity barely affects the observable performance, but in an embedded or in other time-critical even this small performance gain is significant. \medskip
\par The other inefficiency related to \verb|basic_ostream| are the multiple calls to \verb|endl| function which is defined as\cite[\S27.7.3.8]{cpp_standard}:
\begin{verbatim}
template <class charT, class traits>
  basic_ostream<charT,traits>& endl(basic_ostream<charT,traits>& os);
\end{verbatim}
To be able to apply \verb|operator<<| on functions the standard defines the following\cite[\S27.7.3.6]{cpp_standard}: 
\begin{verbatim}
basic_ostream<charT,traits>& operator<<(
   basic_ostream<charT,traits>& (*pf)(basic_ostream<charT,traits>&));
\end{verbatim} 
which enables \verb|operator<<| to take a function, that returns \verb|basic_ostream&|, as an argument. \medbreak
\par With this information one could think that streaming more than one \verb|std::endl| is equivalent to streaming \verb|'\n'| characters. However the standard also states that the \verb|endl| function has to call \verb|flush|\cite[\S27.7.3.8]{cpp_standard} which flushes the output buffer, which is a time consuming procedure. The actual performance overhead caused by flushing the output buffer is operating system dependent, but in general it can be categorized as a performance hog, if used repeatedly. 
\subsubsection{Default Container Initialization Check}
\par The C++ standard defines standard containers which are able to hold collections of objects. The containers which are defined and we are interested in are: \verb|std::vector|, \verb|std::set|, \verb|std::deque| and \verb|std::map|. To put elements in these containers one can define them with the default constructor and later add elements one by one with insertion operations. \medskip
\par Each insertion is a call of a member method for instance \verb|push_back()|, \verb|insert()| and \verb|emplace_back()|. To use these methods right after creating the container is inefficient, because the standard mentions that every mentioned container must have a constructor which takes an initializer list as an argument:
\begin{itemize}
	\item \verb|vector(initializer_list<T>, const Allocator& = Allocator());| where \verb|T| is the Type of the objects in the container \cite[\S23.3.6.2]{cpp_standard}
	\item \verb|map(initializer_list<value_type>...);| where \verb|value_type| is a pair of the key and value type of the \verb|map| \cite[\S23.4.4.2]{cpp_standard}
	\item \verb|set(initializer_list<value_type>...);| where \verb|value_type| is the type of the \verb|set|'s key \cite[\S23.4.6.2]{cpp_standard}
	\item \verb|deque(initializer_list<T>, const Allocator& = Allocator());| where \verb|T| is the Type of the objects in the container\cite[\S23.3.3.2]{cpp_standard}
\end{itemize}
\par The more efficient form would be list-initializing the containers in place with the declaration by passing an \verb|initializer_list| to the constructor. But the list-initialization raises concerns when implicit casting is involved. The standard states "If a narrowing conversion \dots is required to convert any of the arguments, the program is ill-formed"\cite[\S8.5.4 3.6]{cpp_standard}. \medskip
\par A narrowing conversion is an implicit conversion of numerical types where there is possibility of over- or underflow when converting to the destination type. For a more detailed description see \cite[\S8.5.4 7]{cpp_standard}. To remove implicit narrowing conversions we need to introduce explicit casting. This checker uses C-style casts, which in the future should be replaced with a safer \verb|static_cast|.
\subsubsection{Shared Pointer Conversion Check}
\par Accoring to the C++ standard the \verb|memory| header has to contain a templated class \verb|shared_ptr| with the signature \verb|template<class T> class shared_ptr|\cite[\S20.8.2.2]{cpp_standard} \medskip
\par This class is responsible for storing a standard C++ pointer and implementing shared ownership of this raw pointer. This means that the last \verb|shared_ptr| object is responsible for the destruction of the underlying pointer. \medskip
\par The way \verb|shared_ptr| achieves the shared ownership is by a class-wide static variable (\verb|use_count()|) which is incremented in each construction and decremented in each destruction and if \verb|use_count()|  reaches zero in a destruction then the underlying pointer shall be destroyed either by default \verb|delete| keyword or by a user-supplied custom deleter. The modification of the reference count has to be an atomic process and should not be modified simultaneously\cite[\S20.8.2.2 4.]{cpp_standard}. \medskip
\par These properties could make the \verb|shared_ptr| a hidden source of performance hogs when implicit temporary object creation is involved.  Such as the case when inherit is used. \medskip
\par The standard says that a pointer to a derived class shall always be implicit convertible to a pointer to the base class\cite[\S4.10 3.]{cpp_standard}. Also in C++ objects generated  by template instantiations are not covariant, they are invariant in fact, meaning there is no implicit conversion in this example, but a compile time error:
 \begin{lstlisting}[language=c++, frame=single]
struct A {}; struct B : A {};
std::vector<B*> vec1;
std::vector<A*> vec2;
vec2 = vec1;
\end{lstlisting}
\par Yet to make \verb|shared_ptr<A>| covariant, to preserve to resemblence to a raw pointer, the standard defines constructors with signature 
\\ \verb|template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;|\\ 
\verb|template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;| \\
\cite[\S20.8.2.2.1]{cpp_standard}
 which should be eligible for overload resolution if and only  if \verb|T*| is convertible to \verb|Y*|. \medskip
 \par This entails that a \verb|shared_ptr<A>| shall be implicit convertible to \verb|shared_ptr<B>| if \verb|A| is a derived class from \verb|B| and \verb|B| is accessible and unambiguous. But this conversion is costly, because of the reference counting, which in this case decrements the reference count in \verb|shared_ptr<Derived>| and increments in \verb|shared_ptr<Base>|. This incrementing, decrementing is unnecessary and resource consuming. \medskip
 \par To solve this problem, the easiest method is to refactor the function which expects a \verb|shared_ptr<Base>|, to expect a \verb|const Base&| or \verb|const B*| and call the function with either \verb|*ptr.get()| or \verb|ptr.get()|.
\subsection{Implementations}
\subsubsection{Inefficient String Concatenation Check}
\subsubsection{Inefficient Stream Use Check}
\subsubsection{Default Container Initialization Check}
\subsubsection{Shared Pointer Conversion Check}
\subsection{Program Structure}
\par This section covers the abstract structure of the application in Clang-tidy project. The visualization is done with the Unified Modelling Language (UML for short), which is a standard way of representing different logical and physical connections in a computer software. We use UML Class diagrams to visualize the methods and fields of an object, representing also the visibility of these components from the outside of the class.  \medskip
\par In Figure:\ref{inheritence} we visualize each module's ancestor and how these modules are decoupled from each other.  
\begin{figure}[H]
 	\caption{Inheritence diagram}
 	\includegraphics[scale=1]{images/inheritence.pdf}
 	\label{inheritence}
\end{figure}
\par Every module extends from the \verb|ClangTidyCheck| class, which provides the interface of a Clang-tidy module to create the AST-matchers and also how the matched code should be handled afterwards. First step of adding a new module to Clang-tidy is to inherit from this class and implement the methods, which can be used also to send extra parameters to the checkers themselves.
\begin{figure}[H]
	\caption{UML class diagram of Inefficient Stream Use checker}
	\centering
	\includegraphics[scale=1.8]{images/InefficientStreamUse.pdf}
	\label{stream_check_class}
\end{figure}
\par In Figure:\ref{stream_check_class} you can observe one of the simplest module's UML Class diagram, which implements the methods declared by \verb|ClangTidyCheck| and also defines one static free function in the source file.
\begin{figure}[H]
	\caption{UML class diagram of Container Default Initializer check}
	\centering
	\includegraphics[scale=0.85]{images/ContainerDefaultInitializer.pdf}
	\label{container_init_class}
\end{figure}
\par Figure:\ref{container_init_class} represents the abstract structure of the Container Default Initializer check. The solved problem in this module is more complex than the rest hence the increased complexity in the abstract structure. This checker uses several helper functions, and utility classes to store all the meta information about the containers and the conversions taking place in instantiating them. 
\begin{figure}[H]
	\caption{UML class diagram of Inefficient String Concatenation check}
	\centering
	\includegraphics[scale=1.8]{images/InefficientStringConcatenation.pdf}
	\label{string_concat_check}
\end{figure}
\par The next module's architecture is fairly simple again, as seen in Figure:\ref{string_concat_check}. It consists of the basic interface of a Clang-tidy checker, but it uses a new method \verb|storeOptions| to be able to receive a passed parameter, and modify its behaviour accordingly. 
\begin{figure}[H]
	\caption{UML class diagram of Inefficient Shared Pointer check}
	\centering
	\includegraphics[scale=1.8]{images/InefficientSharedPtr.pdf}
	\label{shared_ptr_check}
\end{figure}
\par In Figure:\ref{shared_ptr_check} you can inspect the structure of the Inefficient Shared Pointer checker which declares two extra static methods for retrieving extra information about the matched nodes. 